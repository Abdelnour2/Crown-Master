# Crown Master
#### Video Demo: https://youtu.be/qvIU8HJ9JUc
#### Description:
Crown Master is a Turn-Based Strategy Action Game, the user has to select 2 heroes and combat against 2 randomly selected enemies. Heroes and enemies are stored in 2 different CSV files.
When you open the game you will see the main menu of the game which contains 3 options:
1. Log in (for admins)
2. Play
3. Exit
If the user entered a wrong input a “Invalid Option” message will be printed and the main menu will load again. The user needs to enter the number or the name of the option he wants to select from the options displayed in the menu.
If the player selected 1 or log in, the log in process will start where the player needs to enter the admin’s username and password correctly to log in, the username is Admin, and the password is main123. If one or both information are entered incorrectly the log in process will fail. If the information are entered correctly the admin panel will get displayed started with a welcoming message to the admin and followed with multiple functionalities the player/admin can use:
1. Display Heroes
2. Add a Hero
3. Remove a Hero
4. Display Enemies
5. Add an Enemy
6. Remove an Enemy
7. Log out
The player/admin needs to enter the number of the option he needs to use. If a wrong input has been put, a “Invalid Input” message will be printed and the admin panel will load again. Each time the admin panel loads, the program will read heroes and enemies csv files and store each one of them in 2 lists of dictionaries one for the heroes and the other one is for the enemies. The program reads these files each time the panel loads so it keeps track for any changes in these files.
Option 1: display heroes is a function that takes the list of heroes that has been read when the admin panel loaded and display all the heroes in the list 
Option 2: add hero is a function that takes the list of heroes that has been read when the admin panel loaded and display all the heroes in the list using the display_heroes function and then ask the player/admin to enter the information of the new hero and then check if any of the information is wrong or if the hero already exists in the csv file. If anything is wrong, a proper message will get displayed, “Invalid Input” will get displayed if there is a problem with entered information of the new hero, and “{hero_name} already exists” will get displayed if the hero already exists in the csv file. If everything is fine the new hero will be added to the csv file and then the admin panel will load again.
Option 3: remove hero is a function that takes the list of heroes that has been read when the admin panel loaded and display all the heroes in the list using the display_heroes function and then ask the player/admin to enter the name of the hero he wants to remove, if the name input of the hero is wrong a “Hero not found” message will be printed and the admin panel will load again, if the entered name is correct, the selected hero will get deleted from the csv file and then the admin panel will load again.
Option 4: display enemies is a function that takes the list of enemies that has been read when the admin panel loaded and display all the enemies in the list.
Option 5: add enemy function follows the concept of add_hero function. It takes the list of enemies that has been read in admin panel when it got loaded and display all the enemies in the list using the display_enemies function then asks the player/admin to enter the information of the new enemy and then check if any of the information is wrong or if the enemy already exists in the csv file. If anything is wrong, a proper message will get displayed, “Invalid Input” will get displayed if there is a problem with entered information of the new enemy, and “{enemy_name} already exists” will get displayed if the enemy already exists in the csv file. If everything is fine the new enemy will be added to the csv file and then the admin panel will load again.
Option 6: remove enemy function follows the concept of remove_hero function, it takes the list of enemies that has been read when the admin panel got loaded and display all the enemies in the list using the display_enemies function and then asks the player/admin to enter the name of the enemy he wants to remove, if the name input of the enemy is wrong a “Enemy not found” message will be printed and the admin panel will load again, if the entered name is correct, the selected enemy will get deleted from the csv file and then the admin panel will load again.
Option 7: This option will exit the admin_page function which is the admin panel and return to the main menu. If the user/admin wants to go to the admin panel again he has to log in again.

Now in the main menu, if the player selected 2 or play, the playing process will start with the play_page function. First, this function checks for the number of available heroes and enemies in the csv files. If there are less than 2 heroes a “Not enough heroes to play” message will be printed and the play page will close and the main menu will load again. And if there are no enemies at all in the csv file a “Not enough enemies to play” message will be printed and the play page will close and the main menu will load again. If there are enough heroes and enemies to play, the selection part will start.
The first part of the selection process is letting the player to select 2 different heroes from the heroes list by calling the select_heroes function. This function firstly reads the content of the heroes’ csv file and store the heroes in a list of dictionaries, then it displays these heroes by calling the display_heroes function. After that an empty list will be created to contain the heroes that the player will select. The player needs to enter the name of the hero he wants to select. He can’t select the same hero twice or select a hero that doesn’t exist in the csv file. If he selects the same hero twice a “Already selected” message will be printed and then he will be asked again to enter the name of the second hero. And if he selected a hero that doesn’t exist a “This hero does not exist” message will get printed and then he will be asked again to enter the name of the hero he wants to select. After he selects 2 heroes successfully, a “Done!” message will be printed and then then the function will return the list of the selected heroes to the main play_page.
Then, the second part of the selection process will start which is letting the game to select 2 random enemies from the enemies’ csv file by calling the enemies_random_selection function. This function reads the enemies’ csv file and stores the enemies in a list of dictionaries. Then it selects randomly 2 enemies and stores them in another list and return that list to the main play_page. The game can select 2 enemies of the same type; it’s only not allowed for players.
At this point, the selection process has ended. Now we need to convert the selected heroes and enemies into objects so we can use them in combat and not mess with the csv files. For this reason, I created 3 classes, the main one called Character, it contains 2 variables called name and health, it’s also contains __init__ function with getters and setters to these variables in addition to an __str__ function to print the values of these variables. The other 2 classes are Hero and Enemy classes, both of them have the Character class as a super class so they can inherit the name and health variables. The Hero class contains 3 more variables which are attack1, attack2 and special. The Enemy class contains 2 more variables which are attack1 and attack2. All these classes have the __init__ function with getters and setters function to all their variables in addition to the __str__ functions. Note that all the 3 __str__ functions were used only for personal testing; they are not used in the actual game.
Using these classes, we continue with the play_page function, after the selection process of the heroes and enemies is done, we firstly take the selected heroes list and give it to the convert_heroes_to_objects function. This function takes the list that contains dictionaries of the 2 selected heroes and make a new list where it stores each key value of the dictionaries to a variable, so a total of 5 variables in case of heroes, a name, health, attack1, attack2 and special variables then makes a new Hero object and assigns all these variables to the object and then appends this object to the new heroes_objects list and do the same with the other hero and finally returns the new object list to the play_page. Secondly we take the enemies list and give it to the convert_enemies_to_objects function. This function follows the same concept of converting heroes to objects. It takes the list that contains dictionaries of the 2 selected enemies and make a new list where it stores each key value of the dictionaries to a variable, so a total of 4 variables in case of enemies, a name, health, attack1 and attack2 variables then makes a new Enemy object and assigns all these variables to the object and then appends this object to the new enemies_objects list and do the same with the other enemy and finally returns the new objects list to the play_page.
After successfully making the heroes and enemies objects, now the battle will start by calling the playing function. This function takes the 2 heroes and enemies objects lists. 5 variables are created in this function, rounds_counter, and 4 variables to check if attack2 and the special attack for the 2 heroes are available to use. These 4 variables are named as follows, first_hero_attack2_available_rounds_counter, first_hero_special_available_rounds_counter, second_hero_attack2_available_rounds_counter, second_hero_special_available_rounds_counter. Rounds cycle goes through 4 cycles, round 1 is the turn of hero 1, round 2 is the turn of hero 2, round 3 is the turn of enemy 1, round 4 is the turn of enemy 2. After that rounds_counter will re-set to 1 and the cycle repeats itself. If a hero or an enemy is dead, when his turn comes it will basically be skipped and the next turn will start. For attacks, heroes have 3 types of attacks, attack1 is always available to use, attack2 is always available each 2 turns, and the special attack is always available each 3 turns. Not in game rounds, but specific player turns, for example, If I have to use attack2 for hero 1, I have to play with hero 1 two times before I can use his second attack so technically it means that 9 in game rounds need to be passed to use the second attack. For enemies, they have 2 types of attacks, attack1 and attack2, both of these 2 attacks are always available. When a hero’s turn comes, the player needs to enter the number of the attack he wants to perform. If he enters a wrong number, his turn will be skipped. If he selects a right number of attack, if the attack is not available to use, his turn will also be skipped. If he entered a right number of attack and it was available, he needs to enter the number of enemy he wants to attack, if the selected enemy is dead or the player wrong input, his turn will be skipped. If he entered a right enemy number and the selected enemy is alive, it will get attacked by the chosen attack’s type. When an enemy’s turn comes, it will randomly select a type of attacks and a random hero to attack. The enemy will always make the right moves so no skipping turns are required for enemies.
When implementing this function, I had an issue choosing the right way to counts for rounds and selecting whose turn is now to play. Firstly, I thought about keep tracking of which heroes and enemies are alive and change the rounds_counter cycle based on how many characters are in the game currently, if there’re 4 characters (2 heroes and 2 enemies) then the rounds_counter will go through a cycle of 4 rounds and reset to 1 after 4 rounds. If there’re 3 characters (1 hero and 2 enemies) the rounds_counter will go through a cycle of 3 rounds where it gives 1 round to heroes and 2 rounds for enemies and then reset to 1 after these 3 rounds. If there’re 3 characters (2 heroes and 1 enemy) the rounds_counter will go through a cycle of 3 rounds where it gives 2 rounds to heroes and 1 round for enemies and then reset to 1 after these 3 rounds. If there’re 2 characters (1 hero and 1 enemy) the rounds_counter will go through a cycle of 2 rounds where it gives 1 round to heroes and 1 rounds for enemies and then reset to 1 after these 2 rounds. But this approach also has another issue which is even if I want to give for example 1 round for heroes and 2 rounds for enemies, I needed to think of an approach to know which hero is alive to give him this round. So all these things will unnecessarily complicate the project. I thought about keeping it simple and use a static 4 rounds_counter cycle and if the character is dead, I’ll just skip his turn and go to the next one.
Finally, if all the heroes are dead, the playing function will return “You Lost!” message to the play_page function, and if all the enemies are dead, the playing function will return “You Won!” message to the play_page function. And this message will be printed and then the play_page function will end and the player will return to the main menu.
In the end, in the main menu, if the player selected 3 or exit. The program will be closed by sys.exit and print “Program Closed” message.
And this is an in-details explanation for the whole project.
